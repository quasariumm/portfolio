<div class="pressure p-4 w-full border rounded-lg">
  <h4>Interactive element: Pressure</h4>
  <p class="inline-block align-middle">
    Click on a cell to update its pressure. Drag the arrows to see the pressure
    change. The simulation assumes no solid cells.
  </p>
  <div id="button-holder" class="flex flex-row justify-left gap-4">
    <button
      type="button"
      id="pressure-reset"
      class="btn-reset border rounded-lg px-2 py-1 border-border dark:border-border-dark bg-red dark:bg-red-dark text-base text-crust dark:text-crust-dark"
      >Reset to zero</button
    >
    <button
      type="button"
      id="pressure-random"
      class="btn-randomise border rounded-lg px-2 py-1 border-border dark:border-border-dark bg-teal dark:bg-teal-dark text-base text-crust dark:text-crust-dark"
      >Randomise</button
    >
    <input type="checkbox" name="Run in realtime" id="pressure-realtime" />
    <label for="pressure-realtime" class="flex items-center justify-left"
      >Run in realtime</label
    >
  </div>
  <div class="relative inline-block mt-4 w-full">
    <div id="pressure-grid" class="grid grid-cols-8 grid-rows-8"></div>
    <svg
      id="pressure-arrow-svg"
      class="absolute top-0 left-0 pointer-events-none"></svg>
  </div>
</div>

<style>
  .pressure button,
  .pressure p,
  .pressure label {
    font-size: 1rem !important;
    margin: 0 !important;
  }
  .pressure label {
    margin-left: calc(-2 * var(--spacing)) !important;
  }
  .pressure h4 {
    margin-top: 0 !important;
  }
</style>

<script>
  import {
    gridSize,
    CalculatePressure,
    SolvePressureRedBlack,
  } from "@/components/blog/smoke-simulation/solver";
  import {
    ConfigureSVG,
    RandomiseVelocities,
    ResetPressure,
  } from "@/components/blog/smoke-simulation/visualisations";
  /*
    Arrow drawing and dragging logic was made by Claude.
    The simulation is based on the actual implementation in my project at BUas.
  */

  /*
    Solver
  */
  function UpdatePressure() {
    const toggle = document.getElementById("pressure-realtime");

    if (!toggle.checked) {
      return;
    }

    const cells = document.getElementById("pressure-grid")?.children;

    SolvePressureRedBlack(cellValues, horizontalArrows, verticalArrows);

    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const cell = cells?.item(row * gridSize + col);
        const value = cellValues[row][col];
        cell.textContent = value.toFixed(2);
        if (document.documentElement.classList.contains("dark")) {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(203, 166, 247, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(137, 220, 235, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5
              ? "var(--color-crust-dark)"
              : "var(--color-text-dark)";
        } else {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(136, 57, 239, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(4, 165, 229, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5 ? "var(--color-crust)" : "var(--color-text)";
        }
      }
    }
  }

  setInterval(UpdatePressure, 16);

  /*
    Cell Vals
  */
  const grid = document.getElementById("pressure-grid");
  const svg = document.getElementById("pressure-arrow-svg");

  // Cell values: gridSize x gridSize
  const cellValues = Array(gridSize)
    .fill(0)
    .map(() => Array(gridSize).fill(0));

  // Vertical arrows (up/down): (gridSize+1) x gridSize
  const verticalArrows = Array(gridSize + 1)
    .fill(0)
    .map(() => Array(gridSize).fill(0));

  // Horizontal arrows (left/right): gridSize x (gridSize+1)
  const horizontalArrows = Array(gridSize)
    .fill(0)
    .map(() => Array(gridSize + 1).fill(0));

  let dragState = null;
  let cellSize = 0;

  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      const cell = document.createElement("div");
      cell.className =
        "cell aspect-square border border-border dark:border-border-dark align-middle text-center cursor-pointer select-none flex items-center justify-center text-text dark:text-text-dark";
      cell.textContent = "0.00";
      cell.dataset.row = row;
      cell.dataset.col = col;
      cell.onclick = () => {
        CalculatePressure(
          cellValues,
          horizontalArrows,
          verticalArrows,
          row,
          col
        );
        const value = cellValues[row][col];
        cell.textContent = value.toFixed(2);
        if (document.documentElement.classList.contains("dark")) {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(203, 166, 247, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(137, 220, 235, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5
              ? "var(--color-crust-dark)"
              : "var(--color-text-dark)";
        } else {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(136, 57, 239, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(4, 165, 229, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5 ? "var(--color-crust)" : "var(--color-text)";
        }
      };
      grid.appendChild(cell);
    }
  }

  const gridRect = grid.getBoundingClientRect();
  cellSize = gridRect.width / gridSize;

  /*
    Arrows SVG
  */
  ConfigureSVG(svg, cellSize, startDrag);

  /*
    Dragging
  */
  function startDrag(e) {
    const type = e.target.dataset.type;
    dragState = {
      type: type,
      hitArea: e.target,
      line: e.target.previousElementSibling,
    };

    if (type === "vertical") {
      dragState.lineIdx = parseInt(e.target.dataset.lineIdx);
      dragState.col = parseInt(e.target.dataset.col);
    } else {
      dragState.row = parseInt(e.target.dataset.row);
      dragState.lineIdx = parseInt(e.target.dataset.lineIdx);
    }

    dragState.hitArea.style.cursor = "grabbing";
    document.addEventListener("mousemove", onDrag);
    document.addEventListener("mouseup", endDrag);
  }

  function onDrag(e) {
    if (!dragState) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const { type, line, hitArea } = dragState;

    if (type === "vertical") {
      const { lineIdx, col } = dragState;
      const startX = col * cellSize + cellSize / 2;
      const startY = lineIdx * cellSize;

      const dy = y - startY;
      const newY = startY + dy;

      line.setAttribute("x2", startX);
      line.setAttribute("y2", newY);
      hitArea.setAttribute("cx", startX);
      hitArea.setAttribute("cy", newY);

      verticalArrows[lineIdx][col] = dy / cellSize;
    } else {
      const { row, lineIdx } = dragState;
      const startX = lineIdx * cellSize;
      const startY = row * cellSize + cellSize / 2;

      const dx = x - startX;
      const newX = startX + dx;

      line.setAttribute("x2", newX);
      line.setAttribute("y2", startY);
      hitArea.setAttribute("cx", newX);
      hitArea.setAttribute("cy", startY);

      horizontalArrows[row][lineIdx] = dx / cellSize;
    }
  }

  function endDrag() {
    if (dragState) {
      dragState.hitArea.style.cursor = "grab";
    }
    dragState = null;
    document.removeEventListener("mousemove", onDrag);
    document.removeEventListener("mouseup", endDrag);
  }

  /*
    Button functions
  */

  document.getElementById("pressure-reset")?.addEventListener("click", () => {
    ResetPressure(cellValues, horizontalArrows, verticalArrows, svg);
  });
  document.getElementById("pressure-random")?.addEventListener("click", () => {
    RandomiseVelocities(
      cellValues,
      horizontalArrows,
      verticalArrows,
      svg,
      cellSize
    );
  });

  RandomiseVelocities(
    cellValues,
    horizontalArrows,
    verticalArrows,
    svg,
    cellSize
  );
</script>
