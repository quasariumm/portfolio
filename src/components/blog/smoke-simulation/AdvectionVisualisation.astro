<div class="advect p-4 w-full border rounded-lg">
  <h4>Interactive element: Advection</h4>
  <p class="inline-block align-middle">
    Works the same as the pressure, but I added a button to calculate new
    velocities based on the pressure. Realtime runs 16 iterations of the
    pressure solver.
  </p>
  <div id="button-holder" class="flex flex-row justify-left gap-4">
    <button
      type="button"
      id="advect-reset"
      class="btn-reset border rounded-lg px-2 py-1 border-border dark:border-border-dark bg-red dark:bg-red-dark text-base text-crust dark:text-crust-dark"
      >Reset to zero</button
    >
    <button
      type="button"
      id="advect-random"
      class="btn-randomise border rounded-lg px-2 py-1 border-border dark:border-border-dark bg-teal dark:bg-teal-dark text-base text-crust dark:text-crust-dark"
      >Randomise</button
    >
    <input type="checkbox" name="Run in realtime" id="advect-realtime" />
    <label for="advect-realtime" class="flex items-center justify-left"
      >Run in realtime</label
    >
    <input type="checkbox" name="Advect velocities" id="advect-advect" />
    <label for="advect-advect" class="flex items-center justify-left"
      >Advect</label
    >
  </div>
  <div class="flex flex-row gap-4">
    Display:
    <select name="Display" id="advect-display-select">
      <option value="Pressure">Pressure</option>
      <option value="Divergence">Divergence</option>
    </select>
  </div>
  <div class="relative inline-block mt-4 w-full">
    <div id="advect-grid" class="grid grid-cols-8 grid-rows-8"></div>
    <svg id="advect-arrow-svg" class="absolute top-0 left-0 pointer-events-none"
    ></svg>
  </div>
</div>

<style>
  .advect button,
  .advect p,
  .advect div label {
    font-size: 1rem !important;
    margin: 0 !important;
  }
  .advect div label {
    margin-left: calc(-2 * var(--spacing)) !important;
  }
  .advect h4 {
    margin-top: 0 !important;
  }
</style>

<script>
  import {
    gridSize,
    CalculatePressure,
    CalculateVelocities,
    SolvePressureRedBlack,
    AdvectVelocities,
  } from "@/components/blog/smoke-simulation/solver";
  import {
    ConfigureSVG,
    RandomiseVelocities,
    ResetPressure,
  } from "@/components/blog/smoke-simulation/visualisations";
  /*
    Arrow drawing and dragging logic was made by Claude.
    The simulation is based on the actual implementation in my project at BUas.
  */

  /*
    Solver
  */

  function DetermineVelocities() {
    // console.log(cellValues);
    // console.log(horizontalArrows);
    // console.log(verticalArrows);

    for (let i = 0; i < 16; i++) {
      SolvePressureRedBlack(cellValues, horizontalArrows, verticalArrows);
    }

    CalculateVelocities(
      cellValues,
      cellSize,
      horizontalArrows,
      verticalArrows,
      svg
    );
  }

  setInterval(() => {
    const toggle = document.getElementById("advect-realtime");

    if (toggle.checked) {
      DetermineVelocities();
    }

    const advect = document.getElementById("advect-advect");
    if (advect.checked) {
      AdvectVelocities(
        horizontalArrows,
        horizontalArrowsTemp,
        verticalArrows,
        verticalArrowsTemp
      );
    }

    const select = document.querySelector("#advect-display-select");
    const displayPressure = select.options[0].selected;

    const cells = document.getElementById("advect-grid")?.children;
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const cell = cells?.item(row * gridSize + col);

        let value = 0.0;
        if (displayPressure) {
          value = cellValues[row][col];
        } else {
          // Divergence
          const vLeft = horizontalArrows[row][col];
          const vRight = horizontalArrows[row][col + 1];
          const vUp = verticalArrows[row][col];
          const vDown = verticalArrows[row + 1][col];
          const gradientX = vRight - vLeft;
          const gradientY = vDown - vUp;
          value = gradientX + gradientY;
        }
        if (Math.abs(value) < 0.01) {
          cell.textContent = "0.00";
        } else {
          cell.textContent = value.toFixed(2);
        }

        if (document.documentElement.classList.contains("dark")) {
          if (displayPressure) {
            cell.style.backgroundColor =
              value < 0.0
                ? `rgba(203, 166, 247, ${Math.min(1.0, Math.abs(value) / 10.0)})`
                : `rgba(137, 220, 235, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
            cell.style.color =
              Math.abs(value) > 6.5
                ? "var(--color-crust-dark)"
                : "var(--color-text-dark)";
          } else {
            cell.style.backgroundColor =
              value < 0.0
                ? `rgba(242, 205, 205, ${Math.min(1.0, Math.abs(value))})`
                : `rgba(180, 190, 254, ${Math.min(1.0, Math.abs(value))})`;
            cell.style.color =
              Math.abs(value) > 0.65
                ? "var(--color-crust-dark)"
                : "var(--color-text-dark)";
          }
        } else {
          if (displayPressure) {
            cell.style.backgroundColor =
              value < 0.0
                ? `rgba(136, 57, 239, ${Math.min(1.0, Math.abs(value) / 10.0)})`
                : `rgba(4, 165, 229, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
            cell.style.color =
              Math.abs(value) > 6.5
                ? "var(--color-crust)"
                : "var(--color-text)";
          } else {
            cell.style.backgroundColor =
              value < 0.0
                ? `rgba(221, 120, 120, ${Math.min(1.0, Math.abs(value))})`
                : `rgba(114, 135, 253, ${Math.min(1.0, Math.abs(value))})`;
            cell.style.color =
              Math.abs(value) > 0.65
                ? "var(--color-crust)"
                : "var(--color-text)";
          }
        }
      }
    }
  }, 32);

  /*
    Cell Vals
  */
  const grid = document.getElementById("advect-grid");
  const svg = document.getElementById("advect-arrow-svg");

  // Cell values: gridSize x gridSize
  const cellValues = Array(gridSize)
    .fill(0)
    .map(() => Array(gridSize).fill(0));

  // Vertical arrows (up/down): (gridSize+1) x gridSize
  const verticalArrows = Array(gridSize + 1)
    .fill(0)
    .map(() => Array(gridSize).fill(0));

  // Horizontal arrows (left/right): gridSize x (gridSize+1)
  const horizontalArrows = Array(gridSize)
    .fill(0)
    .map(() => Array(gridSize + 1).fill(0));
    
  // Vertical arrows (up/down): (gridSize+1) x gridSize
  const verticalArrowsTemp = Array(gridSize + 1)
    .fill(0)
    .map(() => Array(gridSize).fill(0));

  // Horizontal arrows (left/right): gridSize x (gridSize+1)
  const horizontalArrowsTemp = Array(gridSize)
    .fill(0)
    .map(() => Array(gridSize + 1).fill(0));

  let dragState = null;
  let cellSize: number = 0;

  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      const cell = document.createElement("div");
      cell.className =
        "cell aspect-square border border-border dark:border-border-dark align-middle text-center cursor-pointer select-none flex items-center justify-center text-text dark:text-text-dark";
      cell.textContent = "0.00";
      cell.dataset.row = row;
      cell.dataset.col = col;
      cell.onclick = () => {
        CalculatePressure(
          cellValues,
          horizontalArrows,
          verticalArrows,
          row,
          col
        );
        const value = cellValues[row][col];
        cell.textContent = value.toFixed(2);
        if (document.documentElement.classList.contains("dark")) {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(203, 166, 247, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(137, 220, 235, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5
              ? "var(--color-crust-dark)"
              : "var(--color-text-dark)";
        } else {
          cell.style.backgroundColor =
            value < 0.0
              ? `rgba(136, 57, 239, ${Math.min(1.0, Math.abs(value) / 10.0)})`
              : `rgba(4, 165, 229, ${Math.min(1.0, Math.abs(value) / 10.0)})`;
          cell.style.color =
            Math.abs(value) > 6.5 ? "var(--color-crust)" : "var(--color-text)";
        }
      };
      grid.appendChild(cell);
    }
  }

  const gridRect = grid.getBoundingClientRect();
  cellSize = gridRect.width / gridSize;

  /*
    Arrows SVG
  */
  ConfigureSVG(svg, cellSize, startDrag);

  /*
    Dragging
  */
  function startDrag(e) {
    const type = e.target.dataset.type;
    dragState = {
      type: type,
      hitArea: e.target,
      line: e.target.previousElementSibling,
    };

    if (type === "vertical") {
      dragState.lineIdx = parseInt(e.target.dataset.lineIdx);
      dragState.col = parseInt(e.target.dataset.col);
    } else {
      dragState.row = parseInt(e.target.dataset.row);
      dragState.lineIdx = parseInt(e.target.dataset.lineIdx);
    }

    dragState.hitArea.style.cursor = "grabbing";
    document.addEventListener("mousemove", onDrag);
    document.addEventListener("mouseup", endDrag);
  }

  function onDrag(e) {
    if (!dragState) return;

    const rect = svg.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const { type, line, hitArea } = dragState;

    if (type === "vertical") {
      const { lineIdx, col } = dragState;
      const startX = col * cellSize + cellSize / 2;
      const startY = lineIdx * cellSize;

      const dy = y - startY;
      const newY = startY + dy;

      line.setAttribute("x2", startX);
      line.setAttribute("y2", newY);
      hitArea.setAttribute("cx", startX);
      hitArea.setAttribute("cy", newY);

      verticalArrows[lineIdx][col] = dy / cellSize;
    } else {
      const { row, lineIdx } = dragState;
      const startX = lineIdx * cellSize;
      const startY = row * cellSize + cellSize / 2;

      const dx = x - startX;
      const newX = startX + dx;

      line.setAttribute("x2", newX);
      line.setAttribute("y2", startY);
      hitArea.setAttribute("cx", newX);
      hitArea.setAttribute("cy", startY);

      horizontalArrows[row][lineIdx] = dx / cellSize;
    }
  }

  function endDrag() {
    if (dragState) {
      dragState.hitArea.style.cursor = "grab";
    }
    dragState = null;
    document.removeEventListener("mousemove", onDrag);
    document.removeEventListener("mouseup", endDrag);
  }

  /*
    Button functions
  */

  document.getElementById("advect-reset")?.addEventListener("click", () => {
    ResetPressure(cellValues, horizontalArrows, verticalArrows, svg);
  });
  document.getElementById("advect-random")?.addEventListener("click", () => {
    RandomiseVelocities(
      cellValues,
      horizontalArrows,
      verticalArrows,
      svg,
      cellSize
    );
  });

  RandomiseVelocities(
    cellValues,
    horizontalArrows,
    verticalArrows,
    svg,
    cellSize
  );
</script>
