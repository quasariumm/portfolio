---
title: 'Smoke Simulation'
description: 'An explanation on how I simulated and rendered smoke for my block B project of my second year at BUas.'
pubDate: 'Jan 9 2026'
category: 'Simulation'
tags: ['rendering', 'dx12', 'compute', 'smoke', 'buas']
---
import PressureVisualisation from '@/components/blog/smoke-simulation/PressureVisualisation.astro';
import VelocityVisualisation from '@/components/blog/smoke-simulation/VelocityVisualisation.astro';
import AdvectionVisualisation from '@/components/blog/smoke-simulation/AdvectionVisualisation.astro';

## Introduction
After seeing the Coding Adventures series by Sebastian Lague on fluid simulation and smoke simulation [^1] I was inspired to experiment with this myself. Initially I wanted to make a particle-based fluid simulator, but because that is rarely used in real-time applications I later settled on making a 3D Eularian smoke simulator. I achieved this by implementing a MAC grid system with a Jacoby pressure solver. The rendering is achieved using a raymarching algorithm that works in the same voxel grid as the pressure solver.

This post is aimed towards people with at minimum a basic game development aspiration and some basic math knowledge or at least the ability to read mathematical equations. 

All interactive elements on this page are inspired by the wonderful visualisations from Sebastian. The web dev part is made with help from Claude, since my web development skills are not great at the time of writing. I recommend to read this on desktop to fully profit from these.

## Simulation
### Grid
At the core of the simulation lies a MAC grid storage system. A MAC grid is a kind of voxel grid storage technique where different values are stored at different positions in the grid. In my case, the grid has the pressures, cell types, temperature and concentration stored at the center of each cell, whereas the velocities are stored on the edges of the cells. This means that the dimensions of the pressure and type buffers need to be $(N\times M\times P)$ where $M,N,P\in\mathbb{N}$ and the velocity component buffers need to have one extra entry in their respective axis to ensure all sides have values. I will follow the convention that any parameter $q$ at the center of cell $(i,j,k)$ in the grid can be written as $q_{i,j,k}$.

<figure>
    <img alt="MAC Grid" src="/blog-images/smoke-simulation/mac-grid.png"/>
    <figcaption>MAC grid visualisation[^2]</figcaption>
</figure>

### The algorithm
The algorithm for solving the MAC grid takes a couple of steps. All these steps are dependent on one another and I have used algorithms that can be done with compute passes.

I made use of `Texture3D` objects in HLSL to store the buffers. This because I can then easily index it using a 3-component vector type and offload the trilinear sampling needed in the advection pass to the GPU's built-in sampling functions. 

All fluid simulations run on the Navier Stokes equation [^3]

$$
\frac{\partial \vec{u}}{\partial t}=-(\vec{u}\cdot \nabla)\vec{u}-\frac{1}{\rho}\nabla p + \nu\nabla^2\vec{u} + f
$$

$$
\nabla\cdot\vec{u}=0
$$

where $\vec{u}=(u,v,w)$ is the velocity, $p$ is the pressure, $\rho$ is the fluid density and $f$ are any applicable external forces.  
Since smoke has zero viscosity, $\nu\nabla^2\vec{u}$ can be removed from the equation.  
For the code, I will use the convention that the velocities stored at a position are of the lesser side. So, $u_{i-1/2,j,k}$ is stored at `u[i][j][k]`, etc.

With this equation, all passes can be broken down and this can be calculated piecewise. I chose to combine the negative divergence $-(\vec{u}\cdot \nabla)\vec{u}$ and the pressure component $-\frac{1}{\rho}\nabla p$ into one pass.

#### Pressure
Rearranging the Navier Stokes equation gives the following formula[^1] for pressure at a point in the grid

$$
p_{i,j,k}=\frac{p_{i+1,j,k} + p_{i-1,j,k} + p_{i,j+1,k} + p_{i,j-1,k} + p_{i,j,k+1} + p_{i,j,k-1}}{6}
$$

$$
-\rho\Delta x\frac{u_{i+1/2,j,k} - u_{i-1/2,j,k} + v_{i,j+1/2,k} - v_{i,j-1/2,k} + w_{i,j,k+1/2} - w_{i,j,k-1/2}}{6\Delta t}
$$

where $\Delta t$ is the time-step since the last simulation frame. For any cell that is solid the pressure and velocity can be set to 0.

This equation is not enough on its own, since there need to be proper bounding conditions to ensure the pressure is calculated correctly. For this, I am using the _slip_ condition which says that for all the solid boundaries, the pressure difference is zero, ensuring that the smoke can easily slip along the boundary. This also means that the edge velocities will always be zero.

<PressureVisualisation/>

Applying this formula on a MAC grid is not enough, because as you might have already spotted the cells are dependent on each other. This means that there needs to be an algorithm in place to relax the values to near their equilibrium.
A simple way to do this is the "Just running the shader a lot of times" method or more formerly known as the [*Jacobi method*](https://en.wikipedia.org/wiki/Jacobi_method). As you can probably also see from the visualisation,
the pressure needs quite a lot of iterations to settle down. To get the most precise result you'd have to run the solver a large number of times, so to keep the system <abbr title="The program taking up at most 16.6ms (60fps)">real-time</abbr> for each pass of the solver the pressure is only updated a fixed amount of times (in my case 16).  
To make this as performant as possible however, the best option is to utilise the GPU for this, but this poses the problem of [race conditions](https://en.wikipedia.org/wiki/Race_condition), hence the need for the shader to use what's called *Red-Black computation*. 
This algorithm first computes the values for the even cells and then for the odd cells. This works flawlessly, since the formula for pressure shows that no diagonal neighbours are being sampled.

<figure>
    <img alt="Red-black in 2D" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F307839482%2Ffigure%2Fdownload%2Ffig2%2FAS%3A1086787170639874%401636121661509%2FRed-black-coloring-of-elements-used-for-parallel-Gauss-Seidel-Black-elements-have-all.jpg&f=1&nofb=1&ipt=826707a6cfbea7e44e19ebe7d8211b152d7297b33e51771991836cd79c5b801a"/>
    <figcaption>Red-black in 2D [[source](hhttps://www.researchgate.net/figure/Red-black-coloring-of-elements-used-for-parallel-Gauss-Seidel-Black-elements-have-all_fig2_307839482)]</figcaption>
</figure>

#### Velocity
This is where the magic of the MAC grid comes to light. Since we have the pressure of all cell centers, getting the velocity simply using the pressure difference to alter the velocities. Written out for all axes:

$$
u_{i+1/2,j,k}=u_{i+1/2,j,k}-\Delta t\cdot\frac{p_{i,j,k}-p_{i-1,j,k}}{\rho\Delta x}
$$

$$
v_{i,j+1/2,k}=v_{i,j+1/2,k}-\Delta t\cdot\frac{p_{i,j,k}-p_{i,j-1,k}}{\rho\Delta x}
$$

$$
w_{i,j,k+1/2}=w_{i,j,k+1/2}-\Delta t\cdot\frac{p_{i,j,k}-p_{i,j,k-1}}{\rho\Delta x}
$$

Applying this pass satisfies the requirement that 

$$
\nabla\cdot\vec{u}=0
$$

or in other words that there is an equal amount of velocity leaving the cell as there is velocity entering.

<VelocityVisualisation/>

In the visualisation, you'll notice that not all pressures drop to zero as you would expect (because velocity tries to equalise the pressure difference). This is because we cannot run the pressure solver enough times to make for an absolute equilibrium.

What you can also notice from the simulation is that there forms a natural vortex pattern in the velocities. This effect will cause the smoke to spread out and create the mushroom cloud shape that is usually associated with rising smoke.

#### Advection
To make the velocities move through the volume the logical approach is to take the current velocity at one of the faces and move that velocity one time step forward.

$$
q^{n+1}_{p+\Delta t\vec{u}^n_p}=q^n_p
$$

where $q$ is any arbitrary value that needs to be advected and $p$ is its position.

This brings one major problem, namely that it is possible but very computationally difficult to distribute the velocity along all edges in the cell the velocity lands in. However, since this a sequence, we can instead can just move one step backwards and put that velocity at the position on the chosen face

$$
q^{n+1}_p=q^n_{p-\Delta t\vec{u}^n_p}
$$

This is computationally very simple, since that only takes two samples of the velocity texture(s). With this method, the second sample only needs to be the component of the face that is being computed.

<AdvectionVisualisation/>

#### Temperature and concentration
Specifically for smoke temperature $T$ and concentration $s$ are needed to make it act properly. Both of the variables are stored at the center of a cell and are advected as for the velocity. Spawners inject concentration into the grid, whereafter the buoyancy force [^2] is applied to the velocities to produce the initial velocity.

$$
\vec{b}=[\alpha s-\beta(T-T_{amb})]\vec{g}
$$

where $\alpha$ and $\beta$ ar non-zero constants that you can set to your liking, $T_{amb}=273\mathrm{K}$ and $\vec{g}=9.81$

This means that both variables are dependent on one another.

## Rendering
Rendering the smoke is done through a simple raymarching algorithm. In my implementation, the origin of the rays are snapped to the bounds of the fluid to not have to trace through a guaranteed empty space.

<figure>
    <img alt="Raymarching" src="http://storage.googleapis.com/wzukusers/user-22455410/images/582d0051864a7RoVu4za/Tracing2.gif"/>
    <figcaption>Raymarching [^5]</figcaption>
</figure>

Each step of the raymarcher, the checked point is shifted over some step size. Then I sample the concentration buffer to know how much if any smoke is at that point. All the concentration values are summed up, whereafter it is used to determine the final opacity and color of the pixel using the formula [^6]:

$$
E=2\cdot e^{-dp}\cdot (1-e^{-2d})\cdot\frac{1}{4\pi}\frac{1-g^2}{1+g^2-2g\cos(\theta)^{3/2}}
$$

where $d$ is the total distance, $p$ is the absorbance coefficient, $\theta$ is the angle between the ray direction and the sunlight direction and $g$ is the eccentricity that defaults to 0.2.

To make the smoke look more 'smoke-like' I apply the noise functions proposed in the $\mathrm{Nubis}^3$ talk [^4]. For this, I take their [3D noise texture](https://bit.ly/NubisVoxelCloudPack) and sample it with the following algorithm 

```hlsl
// Code from VoxelCloudSampler.cg
// https://bit.ly/NubisVoxelCloudPack
float4 noise = Noise.Sample(NoiseSampler, samplePos * 0.1);
float wispyNoise = lerp(noise.r, noise.g, dimensionalProfile);
float billowyTypeGradient = pow(dimensionalProfile, 0.25);
float billowyNoise = lerp(noise.b * 0.3, noise.a * 0.3, billowyTypeGradient);

float noiseComposite = lerp(wispyNoise, billowyNoise, sample);

float uprezzedDensity = ValueErosion(sample, noiseComposite);
float poweredDensity = Tesseract(sample);

uprezzedDensity *= poweredDensity;
uprezzedDensity = pow(uprezzedDensity, lerp(0.3, 0.6, max(0.0001, poweredDensity)));

...

SummedDensity[tId] += uprezzedDensity;
```

## Performance
With a reasonable 200x200x200 MAC grid system and 16 iterations of the pressure solver my simulation settled on an execution time of **TODO**ms.

During the project, I have made several significant optimisations to my fluid solver and rendering algorithm. These include:
- More efficient use of GPU data types. These choices include using `half` over `float` or using `Texture3D` over a `StructuredBuffer` or `ByteAddressBuffer`.
- Making use of shared memory caching. This gains very much in the fluid solver because of the large amount of times a certain pixel is sampled. For example, a pixel of the pressure texture is sampled four times per iteration of the pressure solver. Since I run it with 16 iterations, this racks up quite quickly.
- Using the GPU as much as possible. Optimisations included moving the pressure iteration loop to the GPU to make it benefit the shared memory optimisation and removing the need of having a temporary buffer by saving in shared memory on the GPU and writing to the texture after a memory sync.

Below is a table with the results of the optimisations listed above. Note that the measurements are done on a version some ways into the development and does not resemble the final performance. Do however take these as a reference on how certain changes might impact performance.
| **Addition/Change** | **Time** | **Rel. to baseline** | **Rel. to last** |
| :--- | :---: | :---: | :---: |
| Baseline | 12.42ms | N/A | N/A |
| 3D thread index | 16.43ms | <span style="color: #e78284ff">+32.3%</span> | <span style="color: #e78284ff">+32.3%</span> |
| Buffer ‚ü∂ Texture | 11.13ms | <span style="color: #a6d189ff">-10.4%</span> | <span style="color: #a6d189ff">-32.3%</span> |
| Pressure iterations on the GPU | 8.96ms | <span style="color: #a6d189ff">-27.9%</span> | <span style="color: #a6d189ff">-19.5%</span> |
| Red-Black pressure solver | 7.86ms | <span style="color: #a6d189ff">-36.7%</span> | <span style="color: #a6d189ff">-12.3%</span> |
| Shared memory caching | 4.49ms | <span style="color: #a6d189ff">-63.8%</span> | <span style="color: #a6d189ff">-42.9%</span> |

## Conclusion and Future Work
All in all this project taught me plenty of things about how to do things properly on the GPU. I did not manage to do everything that I wanted, since in the eight weeks I had for the project I spent a vast majority of the time with a broken advection algorithm. Even though this lost me a lot of time, the result still results in this blog post that I hope serves well as a reference for making your own smoke/fluid simulation. During the project I also looked way differently at smoke since now I know what forces make up the movements of smoke.

In the future, I am planning to maybe add light tracing in the mix as well as adding emittance based on temperature. This can then be expanded with ember particles to make for a nice pyrotechnics simulator.

I also do believe that a lot more performance can be squished out of the simulation with the right knowledge and tools. Sadly I did not have time to dive into the nitty-gritty details of my code.

## References
[^1]: S. Lague, "Coding Adventure: Simulating Smoke", 2025, https://www.youtube.com/watch?v=Q78wvrQ9xsU

[^2]: R. Bridson, "Fluid Simulation for Computer Graphics (Second Edition)", 2016

[^3]: K. Crane, I. Llamas, S. Tariq, "Real-Time Simulation and Rendering of 3D Fluids (GPU Gems chapter 30)", 2008, https://www.cs.cmu.edu/~kmcrane/Projects/GPUFluid/paper.pdf

[^4]: A. Schneider, "$\mathrm{Nubis}^3$: Methods (and madness) to model and render immersive real-time voxel-based clouds.", 2023, https://d3d3g8mu99pzk9.cloudfront.net/AndrewSchneider/Nubis%20Cubed.pdf

[^5]: R. Brucks, "Creating a Volumetric Ray Marcher", 2016, https://shaderbits.com/blog/creating-volumetric-ray-marcher

[^6]: E. Ge, D. Liang, Z. Zhang, "Fire Simulation and Rendering", 2020, https://cs184-firesim.github.io/final-report/