---
title: 'Smoke Simulation'
description: 'An explanation on how I simulated and rendered smoke for my block B project of my second year at BUas.'
pubDate: 'Jan 9 2026'
category: 'Simulation'
tags: ['rendering', 'dx12', 'compute', 'smoke', 'buas']
draft: false
---
## Introduction
After seeing the Coding Adventures series by Sebastian Lague on fluid simulation and smoke simulation[^1] I was insprired to experiment with this myself. Initially I wanted to make a particle-based fluid simulator because that is rarely used in real-time applications, but later settled on making a 3D Eularian smoke simulator. I achieved this by implementing a MAC grid system with a Jacoby pressure solver. The rendering is achieved using a raymarching algorithm that works in the same voxel grid as the pressure solver.

In this post, I will assume that you have a little but of math knowledge and that you can read mathematical symbols. I also assume that you know about the compute pipeline and know a bit about how compute shaders work. 

All interactive elements on this page are inspired by the wonderful visualisations from Sebastian.

## Simulation
### Grid
At the core of the simulation lies a MAC grid storage system. A MAC grid is a kind of voxel grid technique where some values are in the center and other on the edges of cells. In my case, the grid has the pressures and cell types stored at the center of each cell, whereas the velocities are stored on the edges of the cells. This means that the pressure and type buffers need to be $(N\times M\times P)$ where $M,N,P\in\mathbb{N}$ and the velocity component buffers need to have one extra entry in their respective axis to ensure all sides have values. I will follow the convention that any parameter $q$ at a point in the grid can be written as $q_{i,j,k}$.

<figure>
    <img alt="MAC Grid" src="/blog-images/smoke-simulation/mac-grid.png"/>
    <figcaption>MAC grid visualisation[^2]</figcaption>
</figure>

For the code, I will use the convention that the 

### The algorithm
The algorithm for solving the MAC grid takes a couple of steps. All these steps are dependent on one another and I have used algorithms that can be done with compute passes.

I made use of `Texture3D` objects in HLSL to store the buffers. This because I can then easily index it using a 3-component vector type and offload the trilinear sampling needed in the advection pass to the GPU's built-in sampling functions. 

All fluid simulations run on the Navier Stokes equation

$$
\frac{\partial \vec{u}}{\partial t}=-(\vec{u}\cdot \nabla \vec{u})-\frac{1}{\rho}\nabla p + f
$$

where $\vec{u}=(u,v,w)$ is the velocity, $p$ is the pressure, $\rho$ is the fluid density and $f$ are any applicable external forces.  
**Note that $u$ is the x component of $\vec{u}$. Read carefully.**

With this equation, all passes can be broken down and this can be calculated piecewise. I chose to combine the negative divergence $-(\vec{u}\cdot \nabla \vec{u})$ and the pressure component $-\frac{1}{\rho}\nabla p$ into one pass and kept the external forces to 0.

#### Pressure
Rearranging the Navier Stokes equation gives the following formula[^1] for pressure at a point in the grid

$$
p_{i,j,k}=\frac{p_{i+1,j,k} + p_{i-1,j,k} + p_{i,j+1,k} + p_{i,j-1,k} + p_{i,j,k+1} + p_{i,j,k-1}}{n}
$$

$$
-\rho\Delta x\frac{u_{i+1/2,j,k} - u_{i-1/2,j,k} + v_{i,j+1/2,k} - v_{i,j-1/2,k} + w_{i,j,k+1/2} - w_{i,j,k-1/2}}{n\Delta t}
$$

where $n$ is the amount of neighbouring fluid cells and $\Delta t$ is the time-step since the last simulation frame. For any cell that is not fluid the pressure and velocity can be set to 0.

> **_TODO: Interactive_**

Applying this formula on a MAC grid is not enough, because as you might have already spotted the cells are dependent on each other. This means that there needs to be an algorithm in place to relax the values to near their equilibrium.
A simple way to do this is the "Just running the shader a lot of times" method or more formerly known as the [*Jacobi method*](https://en.wikipedia.org/wiki/Jacobi_method).  
To make this as performant as possible however, the best option is to utilise the GPU for this, but this poses the problem of race conditions, hence the need for the shader to use what's called *Red-Black computation*. 
This algorithm first computes the values for the even cells and then for the odd cells. This works flawlessly, since the formula for pressure shows that no diagonal neighbours are being sampled.

<figure>
    <img alt="Red-black in 2D" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F307839482%2Ffigure%2Fdownload%2Ffig2%2FAS%3A1086787170639874%401636121661509%2FRed-black-coloring-of-elements-used-for-parallel-Gauss-Seidel-Black-elements-have-all.jpg&f=1&nofb=1&ipt=826707a6cfbea7e44e19ebe7d8211b152d7297b33e51771991836cd79c5b801a"/>
    <figcaption>Red-black in 2D [[source](hhttps://www.researchgate.net/figure/Red-black-coloring-of-elements-used-for-parallel-Gauss-Seidel-Black-elements-have-all_fig2_307839482)]</figcaption>
</figure>

#### Velocity
This is where the magic of the MAC grid comes to light. Since we have the pressure of all cell centers, getting the velocity simply

$$
u_{i+1/2,j,k}=\Delta t\cdot\frac{p_{i,j,k}-p_{i-1,j,k}}{\rho\Delta x}
$$

$$
v_{i,j+1/2,k}=\Delta t\cdot\frac{p_{i,j,k}-p_{i,j-1,k}}{\rho\Delta x}
$$

$$
w_{i,j,k+1/2}=\Delta t\cdot\frac{p_{i,j,k}-p_{i,j,k-1}}{\rho\Delta x}
$$

> **_TODO: Interactive_**

#### Advection

## Rendering

## Lighting

## Performance
With a reasonable 200x200x200 MAC grid system and 16 iterations of the pressure solver my simulation settled on an execution time of 4.49ms, which is not per se great, but this is definitely a step up from the solver before my optimisation spree which ran at 12.42ms.

## References
[^1]: S. Lague, "Coding Adventure: Simulating Smoke", 2025, https://www.youtube.com/watch?v=Q78wvrQ9xsU

[^2]: R. Bridson, "Fluid Simulation for Computer Graphics (Second Edition)", 2016

[^3]: A. Schneider, "$\mathrm{Nubis}^3$: Methods (and madness) to model and render immersive real-time voxel-based clouds.", 2023, https://d3d3g8mu99pzk9.cloudfront.net/AndrewSchneider/Nubis%20Cubed.pdf

[^4]: K. Zhou, Z. Ren, S. Lin, H. Bao, B. Guo, H-Y. Shum, "Real-Time Smoke Rendering Using Compensated Ray Marching", 2008, http://www.kunzhou.net/2008/smoke.pdf

[^5]: K. Crane, I. Llamas, S. Tariq, "Real-Time Simulation and Rendering of 3D Fluids (GPU Gems chapter 30)", 2008, https://www.cs.cmu.edu/~kmcrane/Projects/GPUFluid/paper.pdf

[^6]: R. Brucks, "Creating a Volumetric Ray Marcher", 2016, https://shaderbits.com/blog/creating-volumetric-ray-marcher